{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-authentication-session\n\n\n\n\n\n\nThis library provides a \nzend-expressive-authentication\n\nadapter that handles form-based username/password authentication credentials\nwhere the user details are subsequently stored in a session.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-authentication-session\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "Home"
        },
        {
            "location": "/#zend-expressive-authentication-session",
            "text": "This library provides a  zend-expressive-authentication \nadapter that handles form-based username/password authentication credentials\nwhere the user details are subsequently stored in a session.",
            "title": "zend-expressive-authentication-session"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-authentication-session",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/v1/intro/",
            "text": "zend-expressive-authentication-session\n\n\nThis library provides a \nzend-expressive-authentication adapter\n\nthat handles form-based username/password authentication credentials\nwhere the user details are subsequently stored in a session.\n\n\nWhen a user who has not previously authenticated hits the middleware, it will\nredirect to a page asking for their credentials, as a username/password\ncombination. When they submit this page with valid credentials, the adapter\nwill store user information (which mimimally includes the username, but can also\ninclude authorization roles and other information). Subsequent requests hitting\nthe authentication middleware will then pull the user data from the session,\nmarking the user as authenticated.",
            "title": "Introduction"
        },
        {
            "location": "/v1/intro/#zend-expressive-authentication-session",
            "text": "This library provides a  zend-expressive-authentication adapter \nthat handles form-based username/password authentication credentials\nwhere the user details are subsequently stored in a session.  When a user who has not previously authenticated hits the middleware, it will\nredirect to a page asking for their credentials, as a username/password\ncombination. When they submit this page with valid credentials, the adapter\nwill store user information (which mimimally includes the username, but can also\ninclude authorization roles and other information). Subsequent requests hitting\nthe authentication middleware will then pull the user data from the session,\nmarking the user as authenticated.",
            "title": "zend-expressive-authentication-session"
        },
        {
            "location": "/v1/config/",
            "text": "Configuration\n\n\nYou will need to provide configuration for the adapter to work correctly:\n\n\n\n\n\n\nYou will need to alias the zend-expressive-authentication\n  \nAuthenticationInterface\n to the package's \nPhpSession\n implementation.\n\n\n\n\n\n\nYou will need to ensure a zend-expressive-authentication\n  \nUserRepositoryInterface\n implementation is available and configured.\n\n\n\n\n\n\nYou will need to provide a factory capable of generating a \nUserInterface\n\n  instance, if you do not want to use the default provided by\n  zend-expressive-authentication.\n\n\n\n\n\n\nYou will need to provide a URL or path to which the authentication middleware\n  will \nredirect\n if no user is discovered in the session.\n\n\n\n\n\n\nExample\n\n\nBelow is an example demonstrating authentication configuration you might provide\nwhen using zend-expressive-authentication-session. In particular:\n\n\n\n\n\n\nIt aliases the \nPdoDatabase\n user repository implementation from\n  zend-expressive-authentication as the \nUserRepositoryInterface\n service.\n\n\n\n\n\n\nIt aliases the \nPhpSession\n adapter from this package to the\n  \nAuthenticationInterface\n service.\n\n\n\n\n\n\nIt \ndoes not\n configure a \nZend\\Expressive\\Authentication\\UserInterface\n\n  service, opting to use the default provided by zend-expressive-authentication.\n\n\n\n\n\n\nIt configures the path \n/login\n as the URL to which unauthenticated users will\n  be redirected.\n\n\n\n\n\n\n// in a config/autoload/*.global.php file:\n\ndeclare(strict_types=1);\n\nuse Zend\\Expressive\\Authentication\\AuthenticationInterface;\nuse Zend\\Expressive\\Authentication\\Session\\PhpSession;\nuse Zend\\Expressive\\Authentication\\UserRepositoryInterface;\nuse Zend\\Expressive\\Authentication\\UserRepository\\PdoDatabase;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            AuthenticationInterface::class => PhpSession::class,\n            UserRepositoryInterface::class => PdoDatabase::class,\n        ],\n    ],\n\n    'authentication' => [\n        'redirect' => '/login',\n    ],\n];\n\n\n\nHandling the login\n\n\nOnce you have configured the adapter, \nyou will also need to write a handler that\nwill handle login attempts\n.",
            "title": "Configuration"
        },
        {
            "location": "/v1/config/#configuration",
            "text": "You will need to provide configuration for the adapter to work correctly:    You will need to alias the zend-expressive-authentication\n   AuthenticationInterface  to the package's  PhpSession  implementation.    You will need to ensure a zend-expressive-authentication\n   UserRepositoryInterface  implementation is available and configured.    You will need to provide a factory capable of generating a  UserInterface \n  instance, if you do not want to use the default provided by\n  zend-expressive-authentication.    You will need to provide a URL or path to which the authentication middleware\n  will  redirect  if no user is discovered in the session.",
            "title": "Configuration"
        },
        {
            "location": "/v1/config/#example",
            "text": "Below is an example demonstrating authentication configuration you might provide\nwhen using zend-expressive-authentication-session. In particular:    It aliases the  PdoDatabase  user repository implementation from\n  zend-expressive-authentication as the  UserRepositoryInterface  service.    It aliases the  PhpSession  adapter from this package to the\n   AuthenticationInterface  service.    It  does not  configure a  Zend\\Expressive\\Authentication\\UserInterface \n  service, opting to use the default provided by zend-expressive-authentication.    It configures the path  /login  as the URL to which unauthenticated users will\n  be redirected.    // in a config/autoload/*.global.php file:\n\ndeclare(strict_types=1);\n\nuse Zend\\Expressive\\Authentication\\AuthenticationInterface;\nuse Zend\\Expressive\\Authentication\\Session\\PhpSession;\nuse Zend\\Expressive\\Authentication\\UserRepositoryInterface;\nuse Zend\\Expressive\\Authentication\\UserRepository\\PdoDatabase;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            AuthenticationInterface::class => PhpSession::class,\n            UserRepositoryInterface::class => PdoDatabase::class,\n        ],\n    ],\n\n    'authentication' => [\n        'redirect' => '/login',\n    ],\n];",
            "title": "Example"
        },
        {
            "location": "/v1/config/#handling-the-login",
            "text": "Once you have configured the adapter,  you will also need to write a handler that\nwill handle login attempts .",
            "title": "Handling the login"
        },
        {
            "location": "/v1/login-handler/",
            "text": "Handling an initial login\n\n\nWhen you have configured the adapter, you can drop in the\nzend-expressive-authentication \nAuthenticationMiddleware\n anywhere you need to\nensure you have an authenticated user. However, how do you handle the initial\nauthentication?\n\n\nIn the \nprevious chapter\n, we indicated that you need to configure a\npath to which to redirect when the adapter does not detect a user. In this\nchapter, we'll detail how to create a login handler for processing user\ncredentials.\n\n\nRoughly, what we need to do is:\n\n\n\n\n\n\nCreate a handler that will both display and handle a login form, redirecting\n  to the originally requested location once a successful authentication occurs.\n\n\n\n\n\n\nCreate a template with a form for capturing the username and password.\n\n\n\n\n\n\nCreate a route to the new handler.\n\n\n\n\n\n\nCreate the handler\n\n\nWe will use the \nzend-expressive CLI tooling\n\nto generate our handler, as well as the related factory and template:\n\n\n$ ./vendor/bin/expressive handler:create \"App\\Login\\LoginHandler\"\n\n\n\nBy default, if you have a configured template engine, this will do the\nfollowing:\n\n\n\n\n\n\nCreate the handler for you.\n\n\n\n\n\n\nCreate logic in the handler to render a template and return the contents in\n  a response.\n\n\n\n\n\n\nCreate a factory for the handler.\n\n\n\n\n\n\nCreate a template for you in an appropriate directory.\n\n\n\n\n\n\nWhen it does these things, it provides you with the paths to each as well. In\nour case, we are using the \nPlatesPHP templating integration\n,\nwith a flat application structure, and the following files were either created\nor updated:\n\n\n\n\n\n\nsrc/App/Login/LoginHandler.php\n, which contains the handler class itself.\n\n\n\n\n\n\nsrc/App/Login/LoginHandlerFactory.php\n, which contains the factory for the handler.\n\n\n\n\n\n\nconfig/autoload/zend-expressive-tooling-factories.global.php\n, which maps the\n  handler to its factory for the DI container.\n\n\n\n\n\n\ntemplates/app/login.phtml\n, which contains our template.\n\n\n\n\n\n\nNow that we have created the handler, we can edit it to do the work we need.\n\n\nOur handler will react to two different HTTP methods.\n\n\nFor an initial login request, the \nGET\n method will be used, and we will need to\ndisplay our template. When we do, we will also memoize the originally requested\nURI (using the \nReferer\n request header).\n\n\nWhen the user submits the form, it will be via the \nPOST\n method. When this\nhappens, we will need to validate the submitted credentials; we will do this\nusing the \nPhpSession\n adapter from this package. If login is successful, we\nwill redirect to the originally requested URI, using the value we previously\nstored in our session. If login fails, we will display our template, adding an\nerror message indicating the credentials were invalid.\n\n\nThe generated handler will already compose the \nTemplateRendererInterface\n, and\nrender a template. We will need to add a constructor dependency on the\n\nPhpSession\n adapter, and store that value in a property. Additionally, since we\nwill be performing a redirect for successful POST requests, we will need to add\na requirement on \nZend\\Diactoros\\Response\\RedirectResponse\n in addition to the\nlogic changes in the handler.\n\n\nThe end result should look like this:\n\n\nnamespace App\\Login;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Diactoros\\Response\\RedirectResponse;           // add this line\nuse Zend\\Expressive\\Authentication\\Session\\PhpSession;  // add this line\nuse Zend\\Expressive\\Session\\SessionInterface;           // add this line\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass LoginHandler implements RequestHandlerInterface\n{\n    private const REDIRECT_ATTRIBUTE = 'authentication:redirect';\n\n    /** @var PhpSession */\n    private $adapter;\n\n    /** @var TemplateRendererInterface */\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer, PhpSession $adapter)\n    {\n        $this->renderer = $renderer;\n        $this->adapter = $adapter;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $session  = $request->getAttribute('session');\n        $redirect = $this->getRedirect($request, $session);\n\n        // Handle submitted credentials\n        if ('POST' === $request->getMethod()) {\n            return $this->handleLoginAttempt($request, $session, $redirect);\n        }\n\n        // Display initial login form\n        $session->set(self::REDIRECT_ATTRIBUTE, $redirect);\n        return new HtmlResponse($this->renderer->render(\n            'app::login',\n            []\n        ));\n    }\n\n    private function getRedirect(\n        ServerRequestInterface $request,\n        SessionInterface $session\n    ) : string {\n        $redirect = $session->get(self::REDIRECT_ATTRIBUTE);\n\n        if (! $redirect) {\n            $redirect = $request->getHeaderLine('Referer');\n            if (in_array($redirect, ['', '/login'], true)) {\n                $redirect = '/';\n            }\n        }\n\n        return $redirect;\n    }\n\n    private function handleLoginAttempt(\n        ServerRequestInterface $request,\n        SessionInterface $session,\n        string $redirect\n    ) : ResponseInterface {\n        // Login was successful\n        if ($this->adapter->authenticate($request)) {\n            $session->unset(self::REDIRECT_ATTRIBUTE);\n            return new RedirectResponse($redirect);\n        }\n\n        // Login failed\n        return new HtmlResponse($this->renderer->render(\n            'app::login',\n            ['error' => 'Invalid credentials; please try again']\n        ));\n    }\n}\n\n\n\nWith these changes in place, our handler is now ready. However, we need to\nupdate our factory, as we've added a new dependency!\n\n\nTo do this, run the following from the command line, in the project root\ndirectory:\n\n\n$ rm src/App/Login/LoginHandlerFactory.php\n$ ./vendor/bin/expressive factory:create \"App\\Login\\LoginHandler\"\n\n\n\nThis will regenerate the factory for you.\n\n\nEdit the template\n\n\nWe will now edit the template. The main considerations are:\n\n\n\n\n\n\nIt needs to have a form that submits back to the login page.\n\n\n\n\n\n\nThe form needs both a \nusername\n and a \npassword\n field.\n\n\n\n\n\n\nWe need to display an error message if one was provided.\n\n\n\n\n\n\nOur application is built off the skeleton, and so we are currently using\n\nBootstrap\n for a UI framework. We are also using\nPlatesPHP as noted earlier. As such, we will update the template in\n\ntemplates/app/login.phtml\n to read as follows:\n\n\n<div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-sm\"><form action=\"<?= $this->url('login') ?>\" method=\"post\">\n            <?php if (isset($error)) : ?>\n            <div class=\"alert alert-danger\" role=\"alert\">\n                <?= $this->escapeHtml($error) ?>\n            </div>\n            <?php endif ?>\n\n            <div class=\"form-group\">\n                <label for=\"username\">Username</label>\n                <input type=\"text\" class=\"form-control\" id=\"username\" name=\"username\" placeholder=\"Enter username\">\n            </div>\n\n            <div class=\"form-group\">\n                <label for=\"password\">Password</label>\n                <input type=\"password\" class=\"form-control\" id=\"password\" name=\"password\" placeholder=\"Password\">\n            </div>\n\n            <button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n        </form></div>\n    </div>\n</div>\n\n\n\n\n\nTemplate location and structure\n\n\nKeep in mind the following when reading the above sample:\n\n\n\n\n\n\nIf you are using the modular structure, the template may be in a different\n  location. Use the output from the \nexpressive handler:create\n command to\n  determine the exact location.\n\n\n\n\n\n\nIf you are using a different template engine, the syntax of the template\n  may vary.\n\n\n\n\n\n\nThe HTML may need to vary based on your own site's UI framework and CSS.\n\n\n\n\n\n\n\n\nCreate the route\n\n\nNow that we have the handler and template created, we need to create a route for\nthe new handler that handles two HTTP methods: \nGET\n for displaying the initial\nform, and \nPOST\n for validating submitted credentials. Open up your\n\nconfig/routes.php\n file, and edit it to add the following within its callback:\n\n\n$app->route(\n    '/login',\n    [\n        Zend\\Expressive\\Session\\SessionMiddleware::class,\n        App\\Login\\LoginHandler::class,\n    ],\n    ['GET', 'POST'],\n    'login'\n);\n\n\n\n\n\nUnderstanding the routing\n\n\nYou may not be familiar with the \nroute()\n method, or middleware pipelines. If\nthe above doesn't make sense, keep reading for an explanation.\n\n\nFirst, we are using the \nroute()\n method, as we want to create a \nsingle\n route\nto respond to \nmultiple\n HTTP methods. This method has a required third argument,\nwhich is an array of HTTP methods; we specify \nGET\n and \nPOST\n in this array.\n\n\nSecond, we are indicating that we want the route to respond to the exact path\n\n/login\n; we provide this via the initial method argument.\n\n\nThird, we are providing a name for this route via the optional fourth argument;\nthis is what allows us to call \n$this->url('login')\n in our template in order to\ngenerate the URL to the login page.\n\n\nFinally, for the middleware argument, we are providing a \npipeline\n,\nby providing an \narray\n of middleware to execute. The first item in the pipeline\nis the \nSessionMiddleware\n from zend-expressive-session; this is required to\nensure we have a session container injected into the request. The second item is\nour login handler itself, which will then do the actual work of creating a\nresponse.\n\n\n\n\nWith this route in place, any routes we write that require authentication will\nnow:\n\n\n\n\n\n\nRedirect to the \n/login\n page, which will require that:\n\n\n\n\n\n\nA user provides credentials and submits the form back to the \n/login\n page,\n  which will:\n\n\n\n\n\n\nProcess the credentials via the \nPhpSession\n adapter, which will store\n  identified user details in the session, and:\n\n\n\n\n\n\nUltimately give them access (assuming any roles associated with them are\n  authorized), and:\n\n\n\n\n\n\nRedirect them back to the originally requested page.\n\n\n\n\n\n\nIn the next chapter, we will \ndetail how to require authentication for\nindividual handlers\n.",
            "title": "Login Handlers"
        },
        {
            "location": "/v1/login-handler/#handling-an-initial-login",
            "text": "When you have configured the adapter, you can drop in the\nzend-expressive-authentication  AuthenticationMiddleware  anywhere you need to\nensure you have an authenticated user. However, how do you handle the initial\nauthentication?  In the  previous chapter , we indicated that you need to configure a\npath to which to redirect when the adapter does not detect a user. In this\nchapter, we'll detail how to create a login handler for processing user\ncredentials.  Roughly, what we need to do is:    Create a handler that will both display and handle a login form, redirecting\n  to the originally requested location once a successful authentication occurs.    Create a template with a form for capturing the username and password.    Create a route to the new handler.",
            "title": "Handling an initial login"
        },
        {
            "location": "/v1/login-handler/#create-the-handler",
            "text": "We will use the  zend-expressive CLI tooling \nto generate our handler, as well as the related factory and template:  $ ./vendor/bin/expressive handler:create \"App\\Login\\LoginHandler\"  By default, if you have a configured template engine, this will do the\nfollowing:    Create the handler for you.    Create logic in the handler to render a template and return the contents in\n  a response.    Create a factory for the handler.    Create a template for you in an appropriate directory.    When it does these things, it provides you with the paths to each as well. In\nour case, we are using the  PlatesPHP templating integration ,\nwith a flat application structure, and the following files were either created\nor updated:    src/App/Login/LoginHandler.php , which contains the handler class itself.    src/App/Login/LoginHandlerFactory.php , which contains the factory for the handler.    config/autoload/zend-expressive-tooling-factories.global.php , which maps the\n  handler to its factory for the DI container.    templates/app/login.phtml , which contains our template.    Now that we have created the handler, we can edit it to do the work we need.  Our handler will react to two different HTTP methods.  For an initial login request, the  GET  method will be used, and we will need to\ndisplay our template. When we do, we will also memoize the originally requested\nURI (using the  Referer  request header).  When the user submits the form, it will be via the  POST  method. When this\nhappens, we will need to validate the submitted credentials; we will do this\nusing the  PhpSession  adapter from this package. If login is successful, we\nwill redirect to the originally requested URI, using the value we previously\nstored in our session. If login fails, we will display our template, adding an\nerror message indicating the credentials were invalid.  The generated handler will already compose the  TemplateRendererInterface , and\nrender a template. We will need to add a constructor dependency on the PhpSession  adapter, and store that value in a property. Additionally, since we\nwill be performing a redirect for successful POST requests, we will need to add\na requirement on  Zend\\Diactoros\\Response\\RedirectResponse  in addition to the\nlogic changes in the handler.  The end result should look like this:  namespace App\\Login;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Diactoros\\Response\\RedirectResponse;           // add this line\nuse Zend\\Expressive\\Authentication\\Session\\PhpSession;  // add this line\nuse Zend\\Expressive\\Session\\SessionInterface;           // add this line\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass LoginHandler implements RequestHandlerInterface\n{\n    private const REDIRECT_ATTRIBUTE = 'authentication:redirect';\n\n    /** @var PhpSession */\n    private $adapter;\n\n    /** @var TemplateRendererInterface */\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer, PhpSession $adapter)\n    {\n        $this->renderer = $renderer;\n        $this->adapter = $adapter;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $session  = $request->getAttribute('session');\n        $redirect = $this->getRedirect($request, $session);\n\n        // Handle submitted credentials\n        if ('POST' === $request->getMethod()) {\n            return $this->handleLoginAttempt($request, $session, $redirect);\n        }\n\n        // Display initial login form\n        $session->set(self::REDIRECT_ATTRIBUTE, $redirect);\n        return new HtmlResponse($this->renderer->render(\n            'app::login',\n            []\n        ));\n    }\n\n    private function getRedirect(\n        ServerRequestInterface $request,\n        SessionInterface $session\n    ) : string {\n        $redirect = $session->get(self::REDIRECT_ATTRIBUTE);\n\n        if (! $redirect) {\n            $redirect = $request->getHeaderLine('Referer');\n            if (in_array($redirect, ['', '/login'], true)) {\n                $redirect = '/';\n            }\n        }\n\n        return $redirect;\n    }\n\n    private function handleLoginAttempt(\n        ServerRequestInterface $request,\n        SessionInterface $session,\n        string $redirect\n    ) : ResponseInterface {\n        // Login was successful\n        if ($this->adapter->authenticate($request)) {\n            $session->unset(self::REDIRECT_ATTRIBUTE);\n            return new RedirectResponse($redirect);\n        }\n\n        // Login failed\n        return new HtmlResponse($this->renderer->render(\n            'app::login',\n            ['error' => 'Invalid credentials; please try again']\n        ));\n    }\n}  With these changes in place, our handler is now ready. However, we need to\nupdate our factory, as we've added a new dependency!  To do this, run the following from the command line, in the project root\ndirectory:  $ rm src/App/Login/LoginHandlerFactory.php\n$ ./vendor/bin/expressive factory:create \"App\\Login\\LoginHandler\"  This will regenerate the factory for you.",
            "title": "Create the handler"
        },
        {
            "location": "/v1/login-handler/#edit-the-template",
            "text": "We will now edit the template. The main considerations are:    It needs to have a form that submits back to the login page.    The form needs both a  username  and a  password  field.    We need to display an error message if one was provided.    Our application is built off the skeleton, and so we are currently using Bootstrap  for a UI framework. We are also using\nPlatesPHP as noted earlier. As such, we will update the template in templates/app/login.phtml  to read as follows:  <div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-sm\"><form action=\"<?= $this->url('login') ?>\" method=\"post\">\n            <?php if (isset($error)) : ?>\n            <div class=\"alert alert-danger\" role=\"alert\">\n                <?= $this->escapeHtml($error) ?>\n            </div>\n            <?php endif ?>\n\n            <div class=\"form-group\">\n                <label for=\"username\">Username</label>\n                <input type=\"text\" class=\"form-control\" id=\"username\" name=\"username\" placeholder=\"Enter username\">\n            </div>\n\n            <div class=\"form-group\">\n                <label for=\"password\">Password</label>\n                <input type=\"password\" class=\"form-control\" id=\"password\" name=\"password\" placeholder=\"Password\">\n            </div>\n\n            <button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n        </form></div>\n    </div>\n</div>",
            "title": "Edit the template"
        },
        {
            "location": "/v1/login-handler/#template-location-and-structure",
            "text": "Keep in mind the following when reading the above sample:    If you are using the modular structure, the template may be in a different\n  location. Use the output from the  expressive handler:create  command to\n  determine the exact location.    If you are using a different template engine, the syntax of the template\n  may vary.    The HTML may need to vary based on your own site's UI framework and CSS.",
            "title": "Template location and structure"
        },
        {
            "location": "/v1/login-handler/#create-the-route",
            "text": "Now that we have the handler and template created, we need to create a route for\nthe new handler that handles two HTTP methods:  GET  for displaying the initial\nform, and  POST  for validating submitted credentials. Open up your config/routes.php  file, and edit it to add the following within its callback:  $app->route(\n    '/login',\n    [\n        Zend\\Expressive\\Session\\SessionMiddleware::class,\n        App\\Login\\LoginHandler::class,\n    ],\n    ['GET', 'POST'],\n    'login'\n);",
            "title": "Create the route"
        },
        {
            "location": "/v1/login-handler/#understanding-the-routing",
            "text": "You may not be familiar with the  route()  method, or middleware pipelines. If\nthe above doesn't make sense, keep reading for an explanation.  First, we are using the  route()  method, as we want to create a  single  route\nto respond to  multiple  HTTP methods. This method has a required third argument,\nwhich is an array of HTTP methods; we specify  GET  and  POST  in this array.  Second, we are indicating that we want the route to respond to the exact path /login ; we provide this via the initial method argument.  Third, we are providing a name for this route via the optional fourth argument;\nthis is what allows us to call  $this->url('login')  in our template in order to\ngenerate the URL to the login page.  Finally, for the middleware argument, we are providing a  pipeline ,\nby providing an  array  of middleware to execute. The first item in the pipeline\nis the  SessionMiddleware  from zend-expressive-session; this is required to\nensure we have a session container injected into the request. The second item is\nour login handler itself, which will then do the actual work of creating a\nresponse.   With this route in place, any routes we write that require authentication will\nnow:    Redirect to the  /login  page, which will require that:    A user provides credentials and submits the form back to the  /login  page,\n  which will:    Process the credentials via the  PhpSession  adapter, which will store\n  identified user details in the session, and:    Ultimately give them access (assuming any roles associated with them are\n  authorized), and:    Redirect them back to the originally requested page.    In the next chapter, we will  detail how to require authentication for\nindividual handlers .",
            "title": "Understanding the routing"
        },
        {
            "location": "/v1/requiring-authentication/",
            "text": "Configuring Handlers To Require Authentication\n\n\nIn the \nprevious chapter\n, we detailed writing a handler to\ndisplay a login form for submitting credentials. That handler then redirects\nback to the original URL that required authentication.\n\n\nThis means that the original handler needs to have the\n\nAuthenticationMiddleware\n as part of its pipeline.\n\n\nAdditionally, this package depends on the zend-expressive-session\n\nSessionMiddleware\n being present and in the pipeline before the\nzend-expressive-authentication \nAuthenticationMiddleware\n, as the \nPhpSession\n\nadapter it provides requires access to the session container via the request.\n\n\nThere are three ways to accomplish this:\n\n\n\n\nRequiring authentication everywhere.\n\n\nRequiring authentication for subpaths of the application.\n\n\nRequiring authentication for individual routes.\n\n\n\n\nRequiring authentication everywhere\n\n\nWith this approach, every request other than the one to the login form itself\nwill require authentication. To make this possible, you will need to decorate\nthe zend-expressive-authentication \nAuthenticationMiddleware\n so that you can\nexclude that particular path.\n\n\nAs an example, you could do the following in the \nconfig/pipeline.php\n file,\nbefore the \nRouteMiddleware\n somewhere:\n\n\n// Pipe in the session middleware\n$app->pipe(Zend\\Expressive\\Session\\SessionMiddleware::class);\n\n// Pipe a handler that checks to see if authentication is needed:\n$app->pipe($factory->callable(\n    // $container is present within the callback, and refers to the DI container.\n    function ($request, $handler) use ($container) {\n        if ($request->getUri()->getPath() === '/login') {\n            // Login request; do not require the authentication middleware\n            return $handler->handle($request);\n        }\n\n        // All other requests require the authentication middleware\n        $authenticationMiddleware = $container->get(\n            Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class\n        );\n        return $authenticationMiddleware->process($request, $handler);\n    }\n));\n\n\n\nRequiring authentication for subpaths of the application\n\n\nIf you know all handlers under a given subpath of the application require\nauthentication, you can use Stratigility's \npath segregation features\n\nto add authentication.\n\n\nFor example, consider the following within the \nconfig/pipeline.php\n file, which\nadds authentication to any path starting with \n/admin\n:\n\n\n// Add this within the import section of the file:\nuse function Zend\\Stratigility\\path;\n\n// Add this within the callback, before the routing middleware:\n$app->pipe(path('/admin', $factory->pipeline(\n    Zend\\Expressive\\Session\\SessionMiddleware::class,\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class\n)));\n\n\n\nRequiring authentication for individual routes\n\n\nThe most granular approach involves adding authentication to individual routes.\nIn such cases, you will create a \nroute-specific middleware\npipeline\n.\n\n\nAs an example, if we wanted authentication for each of the routes that use the\npath \n/admin/users[/\\d+]\n, we could do the following within our\n\nconfig/routes.php\n file:\n\n\n$app->get('/admin/users[/\\d+]', [\n    Zend\\Expressive\\Session\\SessionMiddleware::class,\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Users\\UsersHandler::class,\n], 'users');\n$app->post('/admin/users', [\n    Zend\\Expressive\\Session\\SessionMiddleware::class,\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Users\\CreateUserHandler::class,\n]);\n$app->post('/admin/users[/\\d+]', [\n    Zend\\Expressive\\Session\\SessionMiddleware::class,\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Users\\UpdateUserHandler::class,\n]);\n\n\n\nNote that each pipeline contains both the session and authentication middleware!",
            "title": "Handlers Requiring Authentication"
        },
        {
            "location": "/v1/requiring-authentication/#configuring-handlers-to-require-authentication",
            "text": "In the  previous chapter , we detailed writing a handler to\ndisplay a login form for submitting credentials. That handler then redirects\nback to the original URL that required authentication.  This means that the original handler needs to have the AuthenticationMiddleware  as part of its pipeline.  Additionally, this package depends on the zend-expressive-session SessionMiddleware  being present and in the pipeline before the\nzend-expressive-authentication  AuthenticationMiddleware , as the  PhpSession \nadapter it provides requires access to the session container via the request.  There are three ways to accomplish this:   Requiring authentication everywhere.  Requiring authentication for subpaths of the application.  Requiring authentication for individual routes.",
            "title": "Configuring Handlers To Require Authentication"
        },
        {
            "location": "/v1/requiring-authentication/#requiring-authentication-everywhere",
            "text": "With this approach, every request other than the one to the login form itself\nwill require authentication. To make this possible, you will need to decorate\nthe zend-expressive-authentication  AuthenticationMiddleware  so that you can\nexclude that particular path.  As an example, you could do the following in the  config/pipeline.php  file,\nbefore the  RouteMiddleware  somewhere:  // Pipe in the session middleware\n$app->pipe(Zend\\Expressive\\Session\\SessionMiddleware::class);\n\n// Pipe a handler that checks to see if authentication is needed:\n$app->pipe($factory->callable(\n    // $container is present within the callback, and refers to the DI container.\n    function ($request, $handler) use ($container) {\n        if ($request->getUri()->getPath() === '/login') {\n            // Login request; do not require the authentication middleware\n            return $handler->handle($request);\n        }\n\n        // All other requests require the authentication middleware\n        $authenticationMiddleware = $container->get(\n            Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class\n        );\n        return $authenticationMiddleware->process($request, $handler);\n    }\n));",
            "title": "Requiring authentication everywhere"
        },
        {
            "location": "/v1/requiring-authentication/#requiring-authentication-for-subpaths-of-the-application",
            "text": "If you know all handlers under a given subpath of the application require\nauthentication, you can use Stratigility's  path segregation features \nto add authentication.  For example, consider the following within the  config/pipeline.php  file, which\nadds authentication to any path starting with  /admin :  // Add this within the import section of the file:\nuse function Zend\\Stratigility\\path;\n\n// Add this within the callback, before the routing middleware:\n$app->pipe(path('/admin', $factory->pipeline(\n    Zend\\Expressive\\Session\\SessionMiddleware::class,\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class\n)));",
            "title": "Requiring authentication for subpaths of the application"
        },
        {
            "location": "/v1/requiring-authentication/#requiring-authentication-for-individual-routes",
            "text": "The most granular approach involves adding authentication to individual routes.\nIn such cases, you will create a  route-specific middleware\npipeline .  As an example, if we wanted authentication for each of the routes that use the\npath  /admin/users[/\\d+] , we could do the following within our config/routes.php  file:  $app->get('/admin/users[/\\d+]', [\n    Zend\\Expressive\\Session\\SessionMiddleware::class,\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Users\\UsersHandler::class,\n], 'users');\n$app->post('/admin/users', [\n    Zend\\Expressive\\Session\\SessionMiddleware::class,\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Users\\CreateUserHandler::class,\n]);\n$app->post('/admin/users[/\\d+]', [\n    Zend\\Expressive\\Session\\SessionMiddleware::class,\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Users\\UpdateUserHandler::class,\n]);  Note that each pipeline contains both the session and authentication middleware!",
            "title": "Requiring authentication for individual routes"
        },
        {
            "location": "/intro/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-session/v1/intro/';\n  });",
            "title": "_intro"
        }
    ]
}